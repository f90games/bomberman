// Generated by CoffeeScript 1.8.0
(function() {
  var WebSocketServer, connections, engine, handleClientClosure, handleClientMessage, http, httpServer, maxConnections, port, rooms, server, sys, _,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  require('nodetime').profile({
    accountKey: '25e93db5dd4d53be9bd4e8fff5ffe190f19613e3',
    appName: 'Bomberman server'
  });

  sys = require("sys");

  http = require("http");

  WebSocketServer = require("websocket").server;

  _ = require('underscore');

  engine = require("./bm-game");

  maxConnections = 1000;

  connections = {};

  rooms = {};

  port = 9001;

  httpServer = http.createServer(function(req, res) {
    res.writeHead(200, {
      "Content-Type": "text/plain"
    });
    return res.end();
  });

  httpServer.listen(port, function() {
    return sys.log("Listening for connections on port " + port);
  });

  server = new WebSocketServer({
    httpServer: httpServer,
    closeTimeout: 2000
  });

  server.on("request", function(req) {
    var connection, game, hero, level, query, room, state, _ref;
    if (_.size(connections) >= maxConnections) {
      req.reject();
      return;
    }
    connection = req.accept(null, req.origin);
    connection.IP = req.remoteAddress;
    query = req.resourceURL.query;
    if (!query.room) {
      room = _.size(rooms) + 1;
      rooms[room] = {
        count: 1,
        starter: connection
      };
      connection.room = room;
      connection.heroIndex = 0;
      return connection.sendUTF(JSON.stringify({
        type: 'newRoom',
        room: room
      }));
    } else if (rooms[query.room]) {
      if (rooms[query.room].count >= 2) {
        connection.sendUTF(JSON.stringify({
          error: true,
          message: 'The room is buisy!'
        }));
      } else {
        rooms[query.room].count = 2;
        rooms[query.room].starter.peer = connection;
        connection.room = query.room;
        connection.heroIndex = 1;
        connection.peer = rooms[query.room].starter;
        game = new engine.Game;
        state = new engine.GameState({
          currentLevel: 0
        });
        game.setState(state);
        game.makeServerGame();
        level = game.state.level;
        rooms[query.room].game = game;
        hero = new engine.Hero({
          pos: level.heroSpown,
          posTarget: level.heroSpown,
          heroTileIndex: level.heroTileIndex,
          sprite: 0,
          skin: 0,
          hp: 3,
          level: level
        });
        connection.sendUTF(JSON.stringify({
          type: 'newHero',
          data: rooms[query.room].game.state.heros[0]
        }));
        connection.peer.sendUTF(JSON.stringify({
          type: 'newHero',
          data: hero
        }));
        while ((_ref = connection.id, __indexOf.call(connections, _ref) >= 0)) {
          connection.id = Math.floor(Math.random() * 100000);
        }
        connections[connection.id] = connection;
        connection.on("message", function(msg) {
          if (msg.type === "utf8") {
            return handleClientMessage(connection.id, msg.utf8Data);
          }
        });
        connection.on("close", function() {
          return handleClientClosure(connection.id);
        });
        return sys.log("Logged in " + connection.IP + "; currently " + _.size(connections) + " users.");
      }
    }
  });

  handleClientClosure = function(id) {
    var conn, room;
    if (__indexOf.call(connections, id) >= 0) {
      conn = connections[id];
      room = rooms[conn.room];
      sys.log("Disconnect from " + connections[id].IP);
      return delete connections[id];
    }
  };

  handleClientMessage = function(id, msg) {
    var c, e, game;
    if (!(__indexOf.call(connections, id) >= 0)) {
      return;
    }
    try {
      msg = JSON.parse(msg);
    } catch (_error) {
      e = _error;
      return;
    }
    if (!(__indexOf.call(msg, "type") >= 0 && __indexOf.call(msg, "data") >= 0)) {
      return;
    }
    c = connections[id];
    if (!rooms[c.room]) {
      return;
    }
    game = rooms[c.room].game;
    if (!game) {
      return;
    }
    if (msg.type === "D") {
      if (!c.peer) {
        return;
      }
      game.state.heros[c.heroIndex] = msg.data;
      return c.peer.sendUTF(JSON.stringify({
        data: msg.data
      }));
    } else if (msg.type === "B") {
      if (!c.peer) {
        return;
      }
      return c.peer.sendUTF(JSON.stringify({
        type: 'newB',
        b: Message.Data
      }));
    } else if (msg.type === "RESET") {
      if (c.peer) {
        c.peer.sendUTF(JSON.stringify({
          type: 'reset',
          data: {
            level: msg.data.level
          }
        }));
        c.sendUTF(JSON.stringify({
          type: 'newHero',
          data: game.state.heros[c.peer.heroIndex]
        }));
        return c.peer.sendUTF(JSON.stringify({
          type: 'newHero',
          data: game.state.heros[c.heroIndex]
        }));
      }
    }
  };

}).call(this);
